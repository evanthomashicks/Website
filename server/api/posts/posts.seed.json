[
  {
    "Title": "C# 6 and .NET 4.6: Get Hype",
    "Date": "July 23, 2015",
    "Content": "C# 6.0 (and .NET 4.6) has finally, publically, and officially dropped. My hype meter is off the charts. I'm a huge fan of C# - I've been writing programs in it for over two years now and have thoroughly enjoyed it (except for Silverlight! (and CSLA! (and the EDMX!))). C# 6 and .NET 4.6 aren't groundbreaking in the sense of large, crazy awesome features. It's groundbreaking in the sense of small, crazy awesome improvements and more importantly: it's now open source. Mostly. It's a pivotal moment for .NET and another step in an exciting new direction for Microsoft. As a strong OSS proponent, I don't have to feel guilty sitting in my Windows garden anymore. Horray! Here are some of the features Im most excited about: <br><br> <ul><li><b>String Interpolation:</b> In the world of syntatic sugar, this is some pure, in-the-raw, all-natural cane sugar.  When I first started with C#, I was coming from a C/++ background where printf-ing was a mangle of %'s and noob tears. And then I discovered : <br> <div class = \"code-container\"><code>Console.WriteLine(\"C# is {0}!\", foo.WhatIsCSharp)</code></div> <br> Printing just worked! Now, a similar (and even more powerful) operation can be used to create strings : </li> <br> <div class = \"code-container\"><code>$\"{ex.GetType()} encountered hacking the mainframe! The police have {alarm.Triggered ? \"\":\"not\"} been called!\"</code></div> <br> No more fumbling around with <code>+ \" \" +</code>, <code>String.Concat</code>, or <code>String.Join</code>. It's rather declarative and can even be used to simplify Composite Formatting: <div class = code-container><code></code></div></ul>"
  }

  {
    "Title": "Life Imitates TDD",
    "Date": "July 15, 2015",
    "Content": "When I first started practicing Test-Driven Development, it felt strange. Unnatural. My coworkers shared the same sentiment; we realized it was a Good Thing, but did we really <i>have</i> to write tests before we started to code (the answer is yes). Eventually, we saw how great it was and I've become crazy about tests ever since. However, it's only recently that I've realized that the mantra of TDD, Red-Green-Refactor, is how we as humans naturally solve problems. While the process is much less explicit, the steps are strikingly similar.<br><br> <ul><li><b>Think - What is the problem:</b> When faced with a new problem, we start by first defining what the problem is. We ask questions, get advice, and eventually identify at a high level what needs to be done. Often times our experience helps guide us along this process. After deciding on a plan of action and creating our function signature, we press onwards.</li></ul> <ul><li><b>Red - Failure:</b> Failure is essential for success, both in tests and in life. The only difference here are expectations. In life, we don't always expect to fail. Nobody likes to think about failure. In tests, we completely expect it. We must fail and learn in order to succeed. Therefore, we must not fear failure (it is the mind-killer, after all); instead, embrace it as part of the process. Failure gives us confidence that when we do succeed, what we did was no accident. This is critical - we must remember what we did right so we can do it again. Code your logic and conditions for success into your tests, press the button, and try not to panic.</li></ul> <ul><li><b>Green - Success:</b> Now that we've implemented our plan and failed, it's time for some victory. To pass a test, we first write the minimum amount of code to get the green light. In life, we do the same by taking small, easy steps. This helps us focus in on solving just the problem at hand, and steers us away from confusion by keeping things simple. To quote an ancient Earth saying, <i>\"One thing at a time\"</i>. Don't forget to enjoy the feeling when you finally succeed. However, we're not quite done yet.</li></ul> <ul><li><b>Refactor - Get it right:</b> Sometimes we take shortcuts or do Bad Things to succeed. Following success, we usually (or should) analyze our solution and identify what we did right and what we did wrong. The good parts get committed to memory and becomes experience to call upon in the future. The bad parts usually (or should) get fixed. The name of the game is improvement - I'm rarely satisfied by just passing. I want my code to be great.</li></ul>"
  }


]
