[
  {
    "Title": "C# 6 and .NET 4 - Small Stuff",
    "Date": "July 23, 2015",
    "Content":  "C# 6.0 (and .NET 4.6) has finally, publically, and officially dropped. As full-time C# developer (and a big fan of the language), this is quite an exciting time! This update isn't groundbreaking in the sense of large, crazy awesome features. It's groundbreaking in the sense of small, crazy awesome improvements. And even more groundbreaking is the fact that .NET is now open source. Mostly. It's a pivotal moment in the .NET ecosystem and another step in a new direction for Microsoft. Here are some of the features I'm most excited about: <br><br> <ul><li><b>String Interpolation:</b> In the world of syntatic sugar, this is some pure, unrefined, all-natural cane sugar. Strings are among (if not) the most common data type and by far the easiest to make a mess of. Messy strings are particularly annoying because they create a lot of noise - I shouldn't need to care about the specifics of formatting a string for output (looking at you, <code>%d</code>), deal with the hassle of concatenating bits of strings to work with variables, or depend on other libraries to abstract the process away. The first two greviences has C# already has gotten right with composite formatting: <br><br> <div class = \"code-container\"><code>String.Format(\"The rain in {0} falls mainly on the {1}\", \"Spain\", \"plain\")</code></div> <br> However, using composite formatting still requires you to use a class or function that actually implements it (in this case, <code>String.Format</code>). It's certainely less wordy, but the extra dependency still adds noise. Enter string interpolation: </li><br> <div class = \"code-container\"><code>$\"The Year {DateTime.UtcNow, yyyy} is {DateTime.StarDate, yyyy} in StarDate!\"</code></div> <br> There's no more fumbling around with <code>+ \" \" +</code>, <code>String.Concat</code>, or the hassle of lining up the arguments in your composite string.The declarative nature is much less noisy, leading to simpler code which strongly shows your intent. Under the hood, string interpolation compiles into a <code>String.Format></code> object so you're still able to leverage its great features, but it's neatly tucked away - thus reducing the amount of noise to a single <code>$</code>. Much better.<br><br><li><b>Null-Conditional Operator:</b> Nulls are a necessary evil. And where there's a null, there's a null check (hopefully). For thousands of years in C# land the go-to pattern was <code>if (foo != null)</code>. Simple, verbose, ugly, and awful for nested objects. But now: <br><br><div class = \"code-container\"><code>int meaningofLife = DeepThought?.UltimateQuestion?.Answer() ?? 42</code></div><br> It's a short-syntaxed, short-circuiting way to check for pesky nulls. Like String Interpolation, it's not ground-breaking or novel. But it's simple, clean, and cuts the boilerplate cruft. Oh, and it works on indicies too. <br><br> <li><b>.NET Core:</b> In this release Microsoft has officially RTM'd the .NET Core Platform, a an open-source collection of libraries based on the .NET Framework. It consists primarily of the CoreCLR runtime and CoreFX libraries, with Roslyn Compiler more of a sibling project which it supports. Here's a brief rundown of the key components:<br><br> <ul><li><b>Roslyn:</b> A C# and VB compiler platform(!) with code analysis APIs. The philosophy behind this project is to open up the \"black box\" of the compilers through an API, exposing the information it knows and generates. Developers leveraging this API will have a much easier time creating awesome applications that work directly with code. It's a really under-developed area that I'm excited about - perhaps C# macros will soon be on the horizon.</li><br><li><b>CoreCLR:</b> First, a quick rundown of what the CLR is. Simply put, the CLR is a virtual machine which executes .NET code. It receives compiled Common Intermediate Lanauge (CIL) code and packs it into a CIL assembly. When executed by the CLR, this assembly is translated via JIT into native code, which is then executed by the CPU. The fundamental features of the CLR garbage collection, memory and type safety, and high-level language support.<a href=\"https://github.com/dotnet/coreclr/blob/master/Documentation/botr/intro-to-clr.md\">This great article</a> goes much more in depth. The open-sourcing of CoreCLR allows developers to port it cross-platform - in fact, ports of Linux, OSX, and FreeBSD are already passing builds.</li><br><li><b>CoreFX:</b> CoreFX is a set of libraries encapsulating key areas of .NET. This includes, well, pretty much everything in the <code>System.*</code> namespace (even LINQ!). Unlike the CoreCLR, CoreFX is agnostic of CPU or OS - it's compatible with any .NET runtime. If you've ever developed with C# you know how awesome these libraries are. For the average developer, this is probably the most useful piece of the .NET Core.</li></ul><br> The main motivation behind the .NET Core is to allow .NET to be brought cross-platform. By doing this Microsoft is hoping to gain the support, agility, and innovation of the open-source community. With the .NET Framework cross-platforming isn't possible - you must download its entirety including Windows-only libraries. This makes it heavy, hard to port, and unsuitable on anything but Windows. With .NET Core Microsoft has broken key functionality away from Windows-only libraries, paving the way for robust cross-platform implementations and less resource usage. As a bonus it's hosted on GitHub (RIP CodePlex) and distributed via NuGet. Exciting!</li></li>"
  },
]
