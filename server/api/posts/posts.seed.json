[
  {
    "Title": "C# 6 and .NET 4.6: Get Hype",
    "Date": "July 23, 2015",
    "Content": "C# 6.0 (and .NET 4.6) has finally, publically, and officially dropped. My hype meter is off the charts. I'm a huge fan of C# - I've been writing programs in it for over two years now and have thoroughly enjoyed it (except for Silverlight! (and CSLA! (and the EDMX!))). C# 6 and .NET 4.6 aren't groundbreaking in the sense of large, crazy awesome features. It's groundbreaking in the sense of small, crazy awesome improvements and more importantly: it's now open source. Mostly. It's a pivotal moment for .NET and another step in an exciting new direction for Microsoft. As a strong OSS proponent, I don't have to feel guilty sitting in my Windows garden anymore. Horray! Here are some of the features Im most excited about: <br><br> <ul><li><b>String Interpolation:</b> In the world of syntatic sugar, this is some pure, in-the-raw, all-natural cane sugar. Strings are everywhere, and often quite messy - now less so. When I first started with C#, I was coming from a C/++ background where printf-ing was a mangle of %'s and noob tears. And then I discovered:<br><br> <div class = \"code-container\"><code>Console.WriteLine(\"C# is {0}!\", \"neat-o\")</code></div> <br> Printing just worked! Now, a similar (and even more powerful) operation can be used to create strings. Since string interpolation compiles to a <code>String.Format</code> object, it can even be used to create a composite format string. </li><br> <div class = \"code-container\"><code>$\"The Year {DateTime.UtcNow, yyyy} is {DateTime.StarDate, yyyy} in StarDate!\"</code></div> <br> No more fumbling around with <code>+ \" \" +</code>, <code>String.Concat</code>, or <code>String.Join</code>. The declarative nature is much more readable, simple, and really does help when you're trying to line up the Nth <code>{ }</code> in your string. <br><br><li><b>Null-Conditional Operator:</b> Nulls are a necessary evil. And where there's a null, there's a null check (hopefully). For thousands of years in C# land the go-to pattern was <code>if (foo != null)</code>. Simple, verbose, ugly, and awful for nested objects. But now: <br><br><div class = \"code-container\"><code>int meaningofLife = DeepThought?.UltimateQuestion?.Answer() ?? 42</code></div><br> It's a short-syntaxed, short-circuiting way to check for pesky nulls. Like String Interpolation, it's not ground-breaking or novel. But it's simple, clean, and cuts the boilerplate cruft. Oh, and it works on indicies too. <br><br> <li><b>.NET Core:</b> In this release Microsoft has officially RTM'd the .NET Core Platform, a an open-source collection of libraries based on the .NET Framework. It consists primarily of the CoreCLR runtime and CoreFX libraries, with Roslyn Compiler more of a sibling project which it supports. Here's a brief rundown of the key components:<br><br> <ul><li><b>Roslyn:</b> A C# and VB compiler platform(!) with code analysis APIs. The philosophy behind this project is to open up the \"black box\" of the compilers through an API, exposing the information it knows and generates. Developers leveraging this API will have a much easier time creating awesome applications that work directly with code. It's a really under-developed area that I'm excited about - perhaps C# macros will soon be on the horizon!</li><br><li><b>CoreCLR:</b>First, a quick rundown of what a CLR is. Simply put, the CLR is a virtual machine which executes .NET code. It receives compiled Common Intermediate Lanauge (CIL) code and packs it into a CIL assembly. When executed by the CLR, this assembly is translated via JIT into native code, which is then executed by the CPU. The fundamental features of the CLR garbage collection, memory and type safety, and high-level language support.<a href=\"https://github.com/dotnet/coreclr/blob/master/Documentation/botr/intro-to-clr.md\">this great article. </a></b></li></ul><br>The main motivation behind the .NET Core is to allow .NET to be brought cross-platform. By doing this Microsoft is hoping to gain the support, agility, and innovation of the open-source community. With the .NET Framework cross-platforming isn't possible - you must download its entirety including Windows-only libraries. This makes it heavy, hard to port, and unsuitable on anything but Windows. With .NET Core Microsoft has broken  key functionality away from Windows-only libraries, paving the way for robust cross-platform implementations and less resource usage. As a bonus it's hosted on GitHub (RIP CodePlex) and distributed via NuGet. Exciting!</li></li>"
  },

  {
    "Title": "Life Imitates TDD",
    "Date": "July 15, 2015",
    "Content": "When I first started practicing Test-Driven Development, it felt strange. Unnatural. My coworkers shared the same sentiment; we realized it was a Good Thing, but did we really <i>have</i> to write tests before we started to code (the answer is yes). Eventually, we saw how great it was and I've become crazy about tests ever since. However, it's only recently that I've realized that the mantra of TDD, Red-Green-Refactor, is how we as humans naturally solve problems. While the process is much less explicit, the steps are strikingly similar.<br><br> <ul><li><b>Think - What is the problem:</b> When faced with a new problem, we start by first defining what the problem is. We ask questions, get advice, and eventually identify at a high level what needs to be done. Often times our experience helps guide us along this process. After deciding on a plan of action and creating our function signature, we press onwards.</li></ul> <ul><li><b>Red - Failure:</b> Failure is essential for success, both in tests and in life. The only difference here are expectations. In life, we don't always expect to fail. Nobody likes to think about failure. In tests, we completely expect it. We must fail and learn in order to succeed. Therefore, we must not fear failure (it is the mind-killer, after all); instead, embrace it as part of the process. Failure gives us confidence that when we do succeed, what we did was no accident. This is critical - we must remember what we did right so we can do it again. Code your logic and conditions for success into your tests, press the button, and try not to panic.</li></ul> <ul><li><b>Green - Success:</b> Now that we've implemented our plan and failed, it's time for some victory. To pass a test, we first write the minimum amount of code to get the green light. In life, we do the same by taking small, easy steps. This helps us focus in on solving just the problem at hand, and steers us away from confusion by keeping things simple. To quote an ancient Earth saying, <i>\"One thing at a time\"</i>. Don't forget to enjoy the feeling when you finally succeed. However, we're not quite done yet.</li></ul> <ul><li><b>Refactor - Get it right:</b> Sometimes we take shortcuts or do Bad Things to succeed. Following success, we usually (or should) analyze our solution and identify what we did right and what we did wrong. The good parts get committed to memory and becomes experience to call upon in the future. The bad parts usually (or should) get fixed. The name of the game is improvement - I'm rarely satisfied by just passing. I want my code to be great.</li></ul>"
  }


]
